# Panoptic Invariants

## Dev Provided Invariants
- Users of the SFPM can only remove liquidity (via isLong==1 or burning positions) that they have previously added under the same (tickLower, tickUpper, tokenType) key. They cannot remove liquidity owned by other users.
    
- Fees collected from Uniswap during any given operation should not exceed the amount of fees earned by the liquidity owned by the user performing the operation.
    
- Fees paid to a given user should not exceed the amount of fees earned by the liquidity owned by that user.


## Others 
### SemiFungiblePositionManager
**Liquidity Conservation and Verification Invariants**

*Invariant 1: Total Liquidity Integrity*
The sum of net liquidity and removed liquidity must be equivalent to the initially provided total liquidity.

```
netLiquidity + removedLiquidity = totalLiquidity
```

*Invariant 2: Recorded Liquidity Synchronization*
The liquidity recorded for a user's position in the contract must consistently match the actual liquidity in the corresponding Uniswap V3 pool.

```
recordedLiquidity == actualLiquidityInUniswapPool
```

**Fee-related Invariants**

*Fee Growth Invariant*
The accumulated fees for a position must be precisely determined by the fee growth within the liquidity range, adjusted for the baseline fees collected at the last interaction.

```
accumulatedFees = (feeGrowthInside * liquidity) - baseFees
```

*Fee Collection Invariant*
The fees collected by the contract for a position must never surpass the fees generated by the liquidity in the Uniswap V3 pool.

```
collectedFees <= generatedFeesInUniswapPool
```

**Position-related Invariants**

*Position Size Invariant 1*
The size of a position must not exceed the maximum representable amount in an int128 type.

```
positionSize <= type(int128).max
```

*Position Size Invariant*
The size of a position must always be within the bounds of the data types used to represent token amounts in the contract.

```
0 <= positionSize <= type(uint128).max
```


*Token Transfer Invariant*
When transferring a token representing a position, the entire balance of the token ID must be transferred, and the recipient should have none of that token ID.

```
balanceOf(from, tokenId) == amount && balanceOf(to, tokenId) == 0
```


## Relationships Among State Variables

**Liquidity and Pool Initialization**  
The `s_AddrToPoolIdData` mapping establishes a connection between Uniswap V3 pool addresses and their corresponding pool IDs, ensuring unique identification and preventing multiple initializations.

```
s_AddrToPoolIdData[univ3pool] == uint256(poolId) + 2 ** 255 (if initialized)
```

**Fee Collection and Base Fees**  
The `s_accountFeesBase` mapping securely stores baseline fees collected by a position. The association between fees collected and base fees ensures users can only claim fees generated since the last interaction.

```
accumulatedFees == (feeGrowthInside * liquidity) - s_accountFeesBase[positionKey]
```

**Token Transfers**  
The ERC1155 `balanceOf` function and the requirement for entire balance transfers guarantee accurate updates to token ownership.

```
balanceOf(from, tokenId) == amount (pre-transfer)
balanceOf(to, tokenId) == 0 (pre-transfer)
```

